<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>도착지 비용 계산</title>

  <!-- 폰트: 로그인 페이지와 동일 -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;600;700;800&display=swap" rel="stylesheet">

  <link rel="stylesheet" href="./styles.css" />
</head>
<body>
  <div class="page-bg" aria-hidden="true"></div>

  <!-- 상단 바 -->
  <header class="site-header">
    <div class="container header-inner">
      <a class="brand" href="#">
        <img src="https://arrrbang.github.io/pumex/image/pumexlogonew.png" alt="PUMEX Logo" class="brand__logo" />
      </a>
      <a class="header__title" href="#">도착지 비용 계산</a>
      <nav class="header__nav" aria-label="상단 링크"> // 이동할 링크 추가
      </nav>
    </div>
  </header>

  <!-- 메인 -->
  <main class="container section">
    <nav class="tabs" aria-label="카테고리 선택">
      <button class="tab" type="button" id="btnDiplomat">Diplomat</button>
      <button class="tab" type="button" id="btnNonDiplomat">Non-Diplomat</button>
    </nav>
    
<div class="dropdown-container">
  <div class="dropdown" id="dropdownMenu">
    <div class="dropdown-inner">
      <label class="dropdown-label" for="countryCombo">국가 선택</label>
      <div class="combo" id="countryCombo">
        <input type="text" placeholder="국가를 입력/선택 (예: 미국, 중국)" autocomplete="off">
        <div class="list"></div>
      </div>
  
      <div class="dropdown-label-row">
        <span class="label-text">지역 선택</span>
        <button id="btnSelectOnMap" type="button" class="map-button-inline">지도에서 선택</button>

      </div>
      <div class="combo" id="regionCombo">
        <input type="text" placeholder="지역을 입력/선택 (예: A지역, B지역)" autocomplete="off" disabled>
        <div class="list"></div>
      </div>
  
      <label class="dropdown-label" for="companyCombo">업체 선택</label>
      <div class="combo" id="companyCombo">
        <input type="text" placeholder="업체를 입력/선택 (예: A업체, B업체)" autocomplete="off" disabled>
        <div class="list"></div>
      </div>
    </div>
  </div>
</div>
<div class="selection-summary" id="selectionSummary"></div>

<div class="dropdown-container">
  <div class="dropdown" id="nextDropdowns">
    <div class="dropdown-inner">
      <label class="dropdown-label" for="typeCombo">컨테이너 타입</label>
      <div class="combo" id="typeCombo">
        <input type="text" placeholder="20FT / 40HC / CONSOLE" autocomplete="off" value="20FT">
        <div class="list"></div>
      </div>
  
      <label class="dropdown-label" for="cbmSelect">CBM 선택</label>
      <select id="cbmSelect" class="dropdown-select"></select>
    </div><!-- /.dropdown-inner -->
  </div>
</div>
    
<div class="selection-summary" id="nextSelectionSummary"></div>

  <section id="resultSection" class="result-section" aria-live="polite">
    <div id="costList" class="cost-list"></div>
  </section>
    
</main>

<script>
/* =========================
   공통 유틸
========================= */
const BASE = 'https://notion-api-hub.vercel.app';
const $  = (s, r=document)=>r.querySelector(s);

/* =========================
   떠 있는 콤보 팝업 관리자
   - 콤보 .list를 body로 옮겨 overflow 잘림 회피
========================= */
const Floating = (() => {
  const mounts = new Map(); // listEl -> { comboEl, wrap, onScroll, onResize }

  function open(comboEl){
    const input = comboEl.querySelector('input');
    const list  = comboEl.querySelector('.list');
    if(!input || !list) return;

    // 이미 떠 있으면 위치만 갱신
    if(mounts.has(list)){ position(comboEl); return; }

    const wrap = document.createElement('div');
    wrap.className = 'combo-float-wrap';
    wrap.style.position = 'fixed';
    wrap.style.zIndex = '1000';
    wrap.style.left = '0'; wrap.style.top = '0';
    wrap.style.width = '0'; wrap.style.height = '0';
    document.body.appendChild(wrap);

    list.dataset.__float = '1';
    wrap.appendChild(list);

    const onScroll = () => position(comboEl);
    const onResize = () => position(comboEl);
    window.addEventListener('scroll', onScroll, true);
    window.addEventListener('resize', onResize);

    mounts.set(list, { comboEl, wrap, onScroll, onResize });
    position(comboEl);
  }

  function position(comboEl){
    const input = comboEl.querySelector('input');
    const list  = getList(comboEl);
    if(!input || !list) return;

    const r = input.getBoundingClientRect();
    list.style.display = 'block';
    list.style.position = 'fixed';
    list.style.left = `${Math.max(8, r.left)}px`;
    list.style.top  = `${r.bottom + 6}px`;
    list.style.width= `${r.width}px`;

    // 화면 하단 넘치면 위로 띄우기
    const rect = list.getBoundingClientRect();
    const tooLow = rect.bottom > window.innerHeight - 8;
    if(tooLow){
      list.style.top = `${Math.max(8, r.top - 6 - rect.height)}px`;
    }
  }

  function close(comboEl){
    const list = getList(comboEl);
    if(!list) return;
    const mount = mounts.get(list);
    if(!mount) return;

    window.removeEventListener('scroll', mount.onScroll, true);
    window.removeEventListener('resize', mount.onResize);
    mounts.delete(list);

    list.removeAttribute('style');
    list.removeAttribute('data-__float');
    mount.wrap.remove();
    comboEl.appendChild(list);
    list.style.display = 'none';
  }

  function getList(comboEl){
    // 현재 떠 있는 목록이 있으면 그것을 우선 반환
    const floated = document.querySelector('.list[data-__float="1"]');
    return floated || comboEl.querySelector('.list');
  }

  function isInsideFloating(target){
    return !!target.closest('.combo-float-wrap') || !!target.closest('.list[data-__float="1"]');
  }

  return { open, close, position, isInsideFloating };
})();

/* =========================
   타이핑 콤보
========================= */
function makeCombo(el, items=[]){
  const input = el.querySelector('input');
  const list  = el.querySelector('.list');
  let data = [...items];
  let selected = null;

  function render(filter=''){
    const f = (filter||'').trim().toLowerCase();
    list.innerHTML='';
    const filtered = f ? data.filter(x=>x.toLowerCase().includes(f)) : [...data];
    const sorted = filtered.sort((a,b)=>{
      const an=Number(a), bn=Number(b);
      if(!isNaN(an)&&!isNaN(bn)) return an-bn;
      const ap=f && a.toLowerCase().startsWith(f)?0:1;
      const bp=f && b.toLowerCase().startsWith(f)?0:1;
      if(ap!==bp) return ap-bp;
      return a.localeCompare(b, 'ko');
    });
    sorted.forEach(v=>{
      const d=document.createElement('div');
      d.className='item' + (selected===v ? ' is-selected':'');
      d.textContent=v;
      d.addEventListener('click', (e)=>{
        e.stopPropagation();
        selected=v;
        input.value=v;
        // 선택 시: 콤보는 닫는 게 맞음 (패널은 그대로 열려 있어야 함)
        el.classList.remove('open');
        Floating.close(el);
        el.dispatchEvent(new CustomEvent('change',{detail:v}));
      });
      list.appendChild(d);
    });
  }

  function setItems(arr){
    data = [...new Set((arr||[]).filter(Boolean))];
    input.disabled = data.length===0;
    if(document.activeElement!==input) input.value='';
    selected=null;
    render(input.value);
  }

  function getValue(){ return selected || input.value.trim(); }
  function setValue(v){ selected=v||null; input.value=v??''; render(input.value); }

  // 열기/필터
  input.addEventListener('focus', ()=>{
    el.classList.add('open'); render(input.value); Floating.open(el);
  });
  input.addEventListener('input', ()=>{
    el.classList.add('open'); render(input.value); Floating.open(el);
  });

  // Enter → 첫 항목 선택
  input.addEventListener('keydown', (e)=>{
    if(e.key==='Enter'){
      const first=(Floating.isInsideFloating(document.activeElement)?document:el).querySelector('.item');
      if(first) first.click();
    }
  });

  // 내부 이벤트는 바깥 닫힘으로 전파되지 않게
  ['pointerdown','mousedown','click','touchstart'].forEach(evt=>{
    list.addEventListener(evt, e=>e.stopPropagation(), {passive:true});
    input.addEventListener(evt, e=>e.stopPropagation(), {passive:true});
  });

  setItems(items);
  return { setItems, getValue, setValue, root: el, input, list };
}

/* =========================
   요소 참조
========================= */
const btnDiplomat    = $("#btnDiplomat");
const btnNonDiplomat = $("#btnNonDiplomat");
const dropdownMenu   = $("#dropdownMenu");
const nextDropdowns  = $("#nextDropdowns");
const summary        = $("#selectionSummary");
const nextSummary    = $("#nextSelectionSummary");

const countryCombo = makeCombo(document.getElementById('countryCombo'));
const regionCombo  = makeCombo(document.getElementById('regionCombo'));
const companyCombo = makeCombo(document.getElementById('companyCombo'));
const typeCombo    = makeCombo(document.getElementById('typeCombo'), ['20FT','40HC','CONSOLE']);

const cbmSelect    = $("#cbmSelect");

let isDropdownVisible=false;
let isNextVisible=false;

/* =========================
   1단계/2단계 열고 닫기
========================= */
function openFirst(){
  dropdownMenu.classList.add('show');
  summary.classList.remove('show');
  nextDropdowns.classList.remove('show');
  nextSummary.classList.remove('show');
  isDropdownVisible=true;
}
function closeFirst(){
  dropdownMenu.classList.remove('show');
  isDropdownVisible=false;
  setTimeout(()=>{ showFirstSummary(); openSecond(); }, 400);
}
function openSecond(){
  nextDropdowns.classList.add('show');
  nextSummary.classList.remove('show');
  isNextVisible=true;
}
function closeSecond(){
  nextDropdowns.classList.remove('show');
  isNextVisible=false;
  setTimeout(()=>{
    const t = typeCombo.getValue() || '미선택';
    const cbm = cbmSelect?.value ? (cbmSelect.options[cbmSelect.selectedIndex]?.text||cbmSelect.value) : '미선택';
    nextSummary.textContent = `${t} — ${cbm}`;
    nextSummary.classList.add('show');
  }, 400);
}
function showFirstSummary(){
  const c = countryCombo.getValue() || '미선택';
  const r = regionCombo.getValue()  || '미선택';
  const comp = companyCombo.getValue() || '미선택';
  summary.textContent = `${c} — ${r} — ${comp}`;
  summary.classList.add('show');
}

/* 탭 버튼: 같은 클릭 사이클에서 닫힘 방지 위해 pointerdown에서 guard */
function onTabClick(btn){
  // 탭 활성화 토글(디자인은 임의)
  btnDiplomat.classList.toggle('is-active', btn===btnDiplomat);
  btnNonDiplomat.classList.toggle('is-active', btn===btnNonDiplomat);

  if(isDropdownVisible) closeFirst(); else openFirst();
}
btnDiplomat?.addEventListener('click', ()=> onTabClick(btnDiplomat));
btnNonDiplomat?.addEventListener('click', ()=> onTabClick(btnNonDiplomat));

/* 바깥 클릭 시 닫기 — 정확한 내부 판별 */
document.addEventListener('pointerdown', (e)=>{
  // 탭 버튼을 누른 경우는 닫기 판단에서 제외(같은 사이클 중복 닫힘 방지)
  if (e.target.closest('.tab')) return;

  // 1단계: 드롭다운 영역이거나 떠 있는 콤보 팝업이면 닫지 않음
  if(isDropdownVisible){
    const insideDropdown = dropdownMenu.contains(e.target);
    const insideFloating = Floating.isInsideFloating(e.target);
    if(!insideDropdown && !insideFloating){
      closeFirst();
    }
  }

  // 2단계
  if(isNextVisible){
    const inside2 = nextDropdowns.contains(e.target);
    if(!inside2) closeSecond();
  }
}, {passive:true});

/* =========================
   API 연동: 국가→지역→업체
========================= */
async function loadCountries(){
  try{
    const r = await fetch(`${BASE}/api/debug/config`);
    const j = await r.json();
    const countries = j.countries || Object.keys(j.dbStructure||{}) || [];
    countryCombo.setItems(countries);
  }catch(e){ countryCombo.setItems([]); }
}
countryCombo.root.addEventListener('change', async ()=>{
  const country = countryCombo.getValue();
  regionCombo.setItems([]); companyCombo.setItems([]);
  if(!country) return;
  try{
    const r = await fetch(`${BASE}/api/regions/${encodeURIComponent(country)}`);
    const j = await r.json();
    regionCombo.setItems(j.regions||[]);
  }catch(e){ regionCombo.setItems([]); }
});
regionCombo.root.addEventListener('change', async ()=>{
  const country = countryCombo.getValue();
  const region  = regionCombo.getValue();
  companyCombo.setItems([]);
  if(!country || !region) return;
  try{
    const url = `${BASE}/api/companies/by-region?country=${encodeURIComponent(country)}&region=${encodeURIComponent(region)}&mode=options`;
    const r = await fetch(url);
    const j = await r.json();
    companyCombo.setItems(j.companies||[]);
  }catch(e){ companyCombo.setItems([]); }
});

/* =========================
   컨테이너 타입 & CBM
========================= */
function setOptions(selectEl, values, placeholder='CBM 선택'){
  const opts = ['<option value="">'+placeholder+'</option>']
   .concat(values.map(v=>`<option value="${String(v)}">${String(v)}</option>`));
  selectEl.innerHTML = opts.join('');
}
function fillCbmByType(type){
  if(!cbmSelect) return;
  const T=(type||'').toUpperCase();
  let values=[];
  if(!T){ setOptions(cbmSelect,[], 'CBM 선택'); return; }
  if(T==='CONSOLE'){ values = Array.from({length:30},(_,i)=>i+1); }
  else { values = [5,10,15,20,25,30,35,40]; }
  setOptions(cbmSelect, values);
}
typeCombo.root.addEventListener('change', ()=> fillCbmByType(typeCombo.getValue()) );

/* =========================
   초기화
========================= */
window.addEventListener('DOMContentLoaded', async ()=>{
  await loadCountries();

  // 초기 상태에서 패널이 전혀 안 보인다고 느낄 수 있어
  // 첫 탭 클릭 없이 바로 확인하려면 아래 한 줄 임시 활성화:
  // openFirst();

  fillCbmByType(typeCombo.getValue() || '20FT');
});

/* =========================
   MapPicker — ORIGINAL 기반 지도 팝업
   요구사항:
   - 버튼 id="btnSelectOnMap" (클릭 시 팝업)
   - countryCombo / regionCombo: 기존 콤보 인스턴스(권장)
     → 없을 경우 #countryCombo input / #regionCombo input을 자동 fallback
   - ./MAP.JSON 존재 (ORIGINAL과 동일 구조)
========================= */

// ---- 0) 도우미: DOM/리소스 로더 ----
function loadCssOnce(href){ return new Promise((res, rej)=>{ if(document.querySelector(`link[href="${href}"]`)) return res(); const l=document.createElement('link'); l.rel='stylesheet'; l.href=href; l.onload=res; l.onerror=rej; document.head.appendChild(l); }); }
function loadJsOnce(src){ return new Promise((res, rej)=>{ if(document.querySelector(`script[src="${src}"]`)) return res(); const s=document.createElement('script'); s.src=src; s.onload=res; s.onerror=rej; document.head.appendChild(s); }); }
const LCSS  = "https://unpkg.com/leaflet@1.9.4/dist/leaflet.css";
const LJS   = "https://unpkg.com/leaflet@1.9.4/dist/leaflet.js";
const GCSS  = "https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css";
const GJS   = "https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js";

// ---- 1) 콤보 접근: 인스턴스가 있으면 사용, 없으면 input fallback ----
function getCountry(){ if (window.countryCombo?.getValue) return window.countryCombo.getValue(); const el = document.querySelector('#countryCombo input'); return el?.value?.trim() || ''; }
function getRegion(){  if (window.regionCombo?.getValue)  return window.regionCombo.getValue();  const el = document.querySelector('#regionCombo input');  return el?.value?.trim() || ''; }
function setRegion(v){ if (window.regionCombo?.setValue)  return window.regionCombo.setValue(v);  const el = document.querySelector('#regionCombo input');  if(el) el.value = v; }

// ---- 2) 토스트(ORIGINAL 톤) ----
let __sticky = null;
function toast(msg, {sticky=false, timeout=1500}={}) {
  if (sticky) {
    if (__sticky) __sticky.remove();
    const el = document.createElement('div');
    el.innerHTML = `<div style="position:fixed;left:50%;top:16px;transform:translateX(-50%);background:rgba(17,17,17,.92);color:#fff;padding:10px 14px;border-radius:10px;border:1px solid rgba(255,255,255,.15);box-shadow:0 2px 8px rgba(0,0,0,.35);z-index:10000;font-size:13px;display:flex;gap:10px;align-items:center;">
      <span>${msg}</span>
      <button type="button" style="background:#fff;color:#111;border:0;border-radius:8px;padding:6px 10px;cursor:pointer;">닫기</button>
    </div>`;
    el.querySelector('button').onclick = ()=>{ el.remove(); __sticky=null; };
    document.body.appendChild(el); __sticky = el; return;
  }
  const d = document.createElement('div');
  d.textContent = msg;
  d.style.cssText = "position:fixed;left:50%;top:24px;transform:translateX(-50%);background:rgba(0,0,0,.75);color:#fff;padding:8px 12px;border-radius:8px;z-index:10000;font-size:13px;";
  document.body.appendChild(d); setTimeout(()=>d.remove(), timeout);
}

// ---- 3) 아이콘(SVG 핀) ----
function makeSvgPinIcon(color, withLabel=false, labelText="") {
  const svg = `
  <svg class="pin-svg" viewBox="0 0 24 24" aria-hidden="true">
    <path fill="${color}" d="M12 2C8.134 2 5 5.134 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.866-3.134-7-7-7zm0 9.5a2.5 2.5 0 1 1 0-5a2.5 2.5 0 0 1 0 5z"/>
  </svg>`;
  const labelHtml = withLabel ? `<div class="pin-label">${String(labelText).replace(/[&<>"']/g,m=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[m]))}</div>` : "";
  const html = `<div class="pin-wrap">${svg}${labelHtml}</div>`;
  return L.divIcon({ className: "", html, iconSize: [26,26], iconAnchor: [13,26] });
}

// ---- 4) 거리/최근접 ----
function haversineKm(aLat,aLng,bLat,bLng){ const R=6371, dLat=(bLat-aLat)*Math.PI/180, dLng=(bLng-aLng)*Math.PI/180; const A=Math.sin(dLat/2)**2+Math.cos(aLat*Math.PI/180)*Math.cos(bLat*Math.PI/180)*Math.sin(dLng/2)**2; return 2*R*Math.asin(Math.sqrt(A)); }
function findNearest(lat,lng,pts){ if(!pts?.length) return null; let best=null,bd=Infinity; for(const p of pts){ const d=haversineKm(lat,lng,p.lat,p.lng); if(d<bd){best=p;bd=d;} } return {point:best,distanceKm:bd}; }

// ---- 5) 팝업 모달 생성 ----
let map, markerLayer, geocoder, mapInited=false, mapData=null, tmpSearch=null;
const pinReg    = '#2563eb';  // 등록 핀
const pinSearch = '#ef4444';  // 검색 핀

function ensureModal() {
  if (document.getElementById('mapPickerModal')) return;
  const wrap = document.createElement('div');
  wrap.id = 'mapPickerModal';
  wrap.innerHTML = `
    <div class="mpk__backdrop" style="position:fixed;inset:0;background:rgba(0,0,0,.45);z-index:2000;"></div>
    <div class="mpk__panel" style="position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);width:min(95vw,980px);background:#fff;border-radius:16px;box-shadow:0 20px 60px rgba(0,0,0,.35);z-index:2001;display:flex;flex-direction:column;overflow:hidden;">
      <div style="display:flex;align-items:center;justify-content:space-between;padding:12px 16px;border-bottom:1px solid #e5e7eb;">
        <strong style="font-size:16px;color:#111">지도에서 지역 선택</strong>
        <div style="display:flex;gap:8px;">
          <button type="button" id="mpkBtnConfirm" style="border:1px solid #1F9461;background:#1F9461;color:#fff;border-radius:8px;padding:8px 12px;cursor:pointer;">선택 완료</button>
          <button type="button" id="mpkBtnClose"   style="border:1px solid #e5e7eb;background:#fff;color:#111;border-radius:8px;padding:8px 12px;cursor:pointer;">닫기</button>
        </div>
      </div>
      <div id="mpkMap" style="height:520px;"></div>
      <div style="padding:10px 14px;color:#4b5563;font-size:13px;border-top:1px solid #e5e7eb;background:#f8fafc;">
        • 핀을 클릭하면 해당 지역이 자동 선택됩니다. • 돋보기로 위치 검색 가능 • 등록되지 않은 자유 입력은 최근접 등록 지역으로 보정됩니다.
      </div>
    </div>
  `;
  document.body.appendChild(wrap);
  // 닫기
  wrap.querySelector('#mpkBtnClose').onclick = closeModal;
  wrap.querySelector('.mpk__backdrop').onclick = closeModal;
  // 확인(선택 완료)
  wrap.querySelector('#mpkBtnConfirm').onclick = ()=> { closeModal(); };
  // ESC
  document.addEventListener('keydown', (e)=>{ if(e.key==='Escape') closeModal(); });
}

function openModal(){ ensureModal(); document.getElementById('mapPickerModal').style.display='block'; }
function closeModal(){ const m=document.getElementById('mapPickerModal'); if(m) m.style.display='none'; }

// ---- 6) 지도 준비 ----
async function ensureMapReady() {
  if (!mapInited) {
    await loadCssOnce(LCSS); await loadJsOnce(LJS);
    await loadCssOnce(GCSS); await loadJsOnce(GJS);

    const worldBounds = L.latLngBounds([[-85,-180],[85,180]]);
    map = L.map('mpkMap', { center:[20,0], zoom:2, worldCopyJump:false, maxBounds:worldBounds, maxBoundsViscosity:1.0 });
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{ attribution:'&copy; OSM', noWrap:true, bounds:worldBounds }).addTo(map);

    markerLayer = L.layerGroup().addTo(map);

    geocoder = L.Control.geocoder({ defaultMarkGeocode:false })
      .on('markgeocode', (e)=>{
        const c = e.geocode.center;
        // 임시 검색 핀
        if (tmpSearch) { map.removeLayer(tmpSearch); tmpSearch=null; }
        tmpSearch = L.marker(c, {icon: makeSvgPinIcon(pinSearch,false)}).addTo(map);
        map.setView(c, 9);

        // 최근접 등록 지역 안내
        const pts = __countryPoints;
        if (pts?.length) {
          const hit = findNearest(c.lat,c.lng,pts);
          if (hit?.point) { setRegion(hit.point.name); toast(`가장 가까운 등록 지역: ${hit.point.name} (~${hit.distanceKm.toFixed(1)}km)`, {sticky:true}); }
        }
      }).addTo(map);

    // MAP.JSON 로드
    try {
      const r = await fetch('./map.json', { cache:'no-store' });
      mapData = await r.json();
    } catch(e) {
      console.warn('map.json 로드 실패:', e);
      mapData = {};
    }
    mapInited = true;
  }
  setTimeout(()=> map.invalidateSize(), 50);
}

let __countryPoints = [];
function setMapCountry(country) {
  if (!mapInited) return;
  markerLayer.clearLayers(); __countryPoints = [];
  if (!mapData || !mapData[country]) return;

  const pts = mapData[country];
  const bounds = [];
  pts.forEach(p => {
    const m = L.marker([p.lat,p.lng], { icon: makeSvgPinIcon(pinReg,false) })
      .addTo(markerLayer)
      .bindPopup(p.name);
    m.on('click', ()=>{ setRegion(p.name); toast(`지역 선택: ${p.name}`); });
    __countryPoints.push({ ...p, marker:m });
    bounds.push([p.lat,p.lng]);
  });
  if (bounds.length) map.fitBounds(bounds,{padding:[20,20]});
}

// ---- 7) 버튼 연결 ----
const __bindMapBtn = ()=>{
  const btn = document.getElementById('btnSelectOnMap');
  if (!btn) return;
  btn.addEventListener('click', async ()=>{
    openModal();
    await ensureMapReady();
    const c = getCountry();
    if (c) setMapCountry(c);
  }, { once:false });
};
if (document.readyState !== 'loading') __bindMapBtn();
else document.addEventListener('DOMContentLoaded', __bindMapBtn);
  
</script>


</body>
</html>
